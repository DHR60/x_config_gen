// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'reality.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$Reality4Ray {

 bool? get show; String? get target; String? get xver; List<String>? get serverNames; String? get privateKey; String? get minClientVer; String? get maxClientVer; int? get maxTimeDiff; List<String>? get shortIds; String? get mldsa65Seed; LimitFallback4Ray? get limitFallbackUpload; LimitFallback4Ray? get limitFallbackDownload; String? get fingerprint; String? get serverName; String? get password; String? get publicKey; String? get shortId; String? get mldsa65Verify; String? get spiderX;
/// Create a copy of Reality4Ray
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$Reality4RayCopyWith<Reality4Ray> get copyWith => _$Reality4RayCopyWithImpl<Reality4Ray>(this as Reality4Ray, _$identity);

  /// Serializes this Reality4Ray to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Reality4Ray&&(identical(other.show, show) || other.show == show)&&(identical(other.target, target) || other.target == target)&&(identical(other.xver, xver) || other.xver == xver)&&const DeepCollectionEquality().equals(other.serverNames, serverNames)&&(identical(other.privateKey, privateKey) || other.privateKey == privateKey)&&(identical(other.minClientVer, minClientVer) || other.minClientVer == minClientVer)&&(identical(other.maxClientVer, maxClientVer) || other.maxClientVer == maxClientVer)&&(identical(other.maxTimeDiff, maxTimeDiff) || other.maxTimeDiff == maxTimeDiff)&&const DeepCollectionEquality().equals(other.shortIds, shortIds)&&(identical(other.mldsa65Seed, mldsa65Seed) || other.mldsa65Seed == mldsa65Seed)&&(identical(other.limitFallbackUpload, limitFallbackUpload) || other.limitFallbackUpload == limitFallbackUpload)&&(identical(other.limitFallbackDownload, limitFallbackDownload) || other.limitFallbackDownload == limitFallbackDownload)&&(identical(other.fingerprint, fingerprint) || other.fingerprint == fingerprint)&&(identical(other.serverName, serverName) || other.serverName == serverName)&&(identical(other.password, password) || other.password == password)&&(identical(other.publicKey, publicKey) || other.publicKey == publicKey)&&(identical(other.shortId, shortId) || other.shortId == shortId)&&(identical(other.mldsa65Verify, mldsa65Verify) || other.mldsa65Verify == mldsa65Verify)&&(identical(other.spiderX, spiderX) || other.spiderX == spiderX));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hashAll([runtimeType,show,target,xver,const DeepCollectionEquality().hash(serverNames),privateKey,minClientVer,maxClientVer,maxTimeDiff,const DeepCollectionEquality().hash(shortIds),mldsa65Seed,limitFallbackUpload,limitFallbackDownload,fingerprint,serverName,password,publicKey,shortId,mldsa65Verify,spiderX]);

@override
String toString() {
  return 'Reality4Ray(show: $show, target: $target, xver: $xver, serverNames: $serverNames, privateKey: $privateKey, minClientVer: $minClientVer, maxClientVer: $maxClientVer, maxTimeDiff: $maxTimeDiff, shortIds: $shortIds, mldsa65Seed: $mldsa65Seed, limitFallbackUpload: $limitFallbackUpload, limitFallbackDownload: $limitFallbackDownload, fingerprint: $fingerprint, serverName: $serverName, password: $password, publicKey: $publicKey, shortId: $shortId, mldsa65Verify: $mldsa65Verify, spiderX: $spiderX)';
}


}

/// @nodoc
abstract mixin class $Reality4RayCopyWith<$Res>  {
  factory $Reality4RayCopyWith(Reality4Ray value, $Res Function(Reality4Ray) _then) = _$Reality4RayCopyWithImpl;
@useResult
$Res call({
 bool? show, String? target, String? xver, List<String>? serverNames, String? privateKey, String? minClientVer, String? maxClientVer, int? maxTimeDiff, List<String>? shortIds, String? mldsa65Seed, LimitFallback4Ray? limitFallbackUpload, LimitFallback4Ray? limitFallbackDownload, String? fingerprint, String? serverName, String? password, String? publicKey, String? shortId, String? mldsa65Verify, String? spiderX
});


$LimitFallback4RayCopyWith<$Res>? get limitFallbackUpload;$LimitFallback4RayCopyWith<$Res>? get limitFallbackDownload;

}
/// @nodoc
class _$Reality4RayCopyWithImpl<$Res>
    implements $Reality4RayCopyWith<$Res> {
  _$Reality4RayCopyWithImpl(this._self, this._then);

  final Reality4Ray _self;
  final $Res Function(Reality4Ray) _then;

/// Create a copy of Reality4Ray
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? show = freezed,Object? target = freezed,Object? xver = freezed,Object? serverNames = freezed,Object? privateKey = freezed,Object? minClientVer = freezed,Object? maxClientVer = freezed,Object? maxTimeDiff = freezed,Object? shortIds = freezed,Object? mldsa65Seed = freezed,Object? limitFallbackUpload = freezed,Object? limitFallbackDownload = freezed,Object? fingerprint = freezed,Object? serverName = freezed,Object? password = freezed,Object? publicKey = freezed,Object? shortId = freezed,Object? mldsa65Verify = freezed,Object? spiderX = freezed,}) {
  return _then(_self.copyWith(
show: freezed == show ? _self.show : show // ignore: cast_nullable_to_non_nullable
as bool?,target: freezed == target ? _self.target : target // ignore: cast_nullable_to_non_nullable
as String?,xver: freezed == xver ? _self.xver : xver // ignore: cast_nullable_to_non_nullable
as String?,serverNames: freezed == serverNames ? _self.serverNames : serverNames // ignore: cast_nullable_to_non_nullable
as List<String>?,privateKey: freezed == privateKey ? _self.privateKey : privateKey // ignore: cast_nullable_to_non_nullable
as String?,minClientVer: freezed == minClientVer ? _self.minClientVer : minClientVer // ignore: cast_nullable_to_non_nullable
as String?,maxClientVer: freezed == maxClientVer ? _self.maxClientVer : maxClientVer // ignore: cast_nullable_to_non_nullable
as String?,maxTimeDiff: freezed == maxTimeDiff ? _self.maxTimeDiff : maxTimeDiff // ignore: cast_nullable_to_non_nullable
as int?,shortIds: freezed == shortIds ? _self.shortIds : shortIds // ignore: cast_nullable_to_non_nullable
as List<String>?,mldsa65Seed: freezed == mldsa65Seed ? _self.mldsa65Seed : mldsa65Seed // ignore: cast_nullable_to_non_nullable
as String?,limitFallbackUpload: freezed == limitFallbackUpload ? _self.limitFallbackUpload : limitFallbackUpload // ignore: cast_nullable_to_non_nullable
as LimitFallback4Ray?,limitFallbackDownload: freezed == limitFallbackDownload ? _self.limitFallbackDownload : limitFallbackDownload // ignore: cast_nullable_to_non_nullable
as LimitFallback4Ray?,fingerprint: freezed == fingerprint ? _self.fingerprint : fingerprint // ignore: cast_nullable_to_non_nullable
as String?,serverName: freezed == serverName ? _self.serverName : serverName // ignore: cast_nullable_to_non_nullable
as String?,password: freezed == password ? _self.password : password // ignore: cast_nullable_to_non_nullable
as String?,publicKey: freezed == publicKey ? _self.publicKey : publicKey // ignore: cast_nullable_to_non_nullable
as String?,shortId: freezed == shortId ? _self.shortId : shortId // ignore: cast_nullable_to_non_nullable
as String?,mldsa65Verify: freezed == mldsa65Verify ? _self.mldsa65Verify : mldsa65Verify // ignore: cast_nullable_to_non_nullable
as String?,spiderX: freezed == spiderX ? _self.spiderX : spiderX // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}
/// Create a copy of Reality4Ray
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$LimitFallback4RayCopyWith<$Res>? get limitFallbackUpload {
    if (_self.limitFallbackUpload == null) {
    return null;
  }

  return $LimitFallback4RayCopyWith<$Res>(_self.limitFallbackUpload!, (value) {
    return _then(_self.copyWith(limitFallbackUpload: value));
  });
}/// Create a copy of Reality4Ray
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$LimitFallback4RayCopyWith<$Res>? get limitFallbackDownload {
    if (_self.limitFallbackDownload == null) {
    return null;
  }

  return $LimitFallback4RayCopyWith<$Res>(_self.limitFallbackDownload!, (value) {
    return _then(_self.copyWith(limitFallbackDownload: value));
  });
}
}


/// Adds pattern-matching-related methods to [Reality4Ray].
extension Reality4RayPatterns on Reality4Ray {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _Reality4Ray value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _Reality4Ray() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _Reality4Ray value)  $default,){
final _that = this;
switch (_that) {
case _Reality4Ray():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _Reality4Ray value)?  $default,){
final _that = this;
switch (_that) {
case _Reality4Ray() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( bool? show,  String? target,  String? xver,  List<String>? serverNames,  String? privateKey,  String? minClientVer,  String? maxClientVer,  int? maxTimeDiff,  List<String>? shortIds,  String? mldsa65Seed,  LimitFallback4Ray? limitFallbackUpload,  LimitFallback4Ray? limitFallbackDownload,  String? fingerprint,  String? serverName,  String? password,  String? publicKey,  String? shortId,  String? mldsa65Verify,  String? spiderX)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _Reality4Ray() when $default != null:
return $default(_that.show,_that.target,_that.xver,_that.serverNames,_that.privateKey,_that.minClientVer,_that.maxClientVer,_that.maxTimeDiff,_that.shortIds,_that.mldsa65Seed,_that.limitFallbackUpload,_that.limitFallbackDownload,_that.fingerprint,_that.serverName,_that.password,_that.publicKey,_that.shortId,_that.mldsa65Verify,_that.spiderX);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( bool? show,  String? target,  String? xver,  List<String>? serverNames,  String? privateKey,  String? minClientVer,  String? maxClientVer,  int? maxTimeDiff,  List<String>? shortIds,  String? mldsa65Seed,  LimitFallback4Ray? limitFallbackUpload,  LimitFallback4Ray? limitFallbackDownload,  String? fingerprint,  String? serverName,  String? password,  String? publicKey,  String? shortId,  String? mldsa65Verify,  String? spiderX)  $default,) {final _that = this;
switch (_that) {
case _Reality4Ray():
return $default(_that.show,_that.target,_that.xver,_that.serverNames,_that.privateKey,_that.minClientVer,_that.maxClientVer,_that.maxTimeDiff,_that.shortIds,_that.mldsa65Seed,_that.limitFallbackUpload,_that.limitFallbackDownload,_that.fingerprint,_that.serverName,_that.password,_that.publicKey,_that.shortId,_that.mldsa65Verify,_that.spiderX);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( bool? show,  String? target,  String? xver,  List<String>? serverNames,  String? privateKey,  String? minClientVer,  String? maxClientVer,  int? maxTimeDiff,  List<String>? shortIds,  String? mldsa65Seed,  LimitFallback4Ray? limitFallbackUpload,  LimitFallback4Ray? limitFallbackDownload,  String? fingerprint,  String? serverName,  String? password,  String? publicKey,  String? shortId,  String? mldsa65Verify,  String? spiderX)?  $default,) {final _that = this;
switch (_that) {
case _Reality4Ray() when $default != null:
return $default(_that.show,_that.target,_that.xver,_that.serverNames,_that.privateKey,_that.minClientVer,_that.maxClientVer,_that.maxTimeDiff,_that.shortIds,_that.mldsa65Seed,_that.limitFallbackUpload,_that.limitFallbackDownload,_that.fingerprint,_that.serverName,_that.password,_that.publicKey,_that.shortId,_that.mldsa65Verify,_that.spiderX);case _:
  return null;

}
}

}

/// @nodoc

@JsonSerializable(explicitToJson: true)
class _Reality4Ray implements Reality4Ray {
  const _Reality4Ray({this.show, this.target, this.xver, final  List<String>? serverNames, this.privateKey, this.minClientVer, this.maxClientVer, this.maxTimeDiff, final  List<String>? shortIds, this.mldsa65Seed, this.limitFallbackUpload, this.limitFallbackDownload, this.fingerprint, this.serverName, this.password, this.publicKey, this.shortId, this.mldsa65Verify, this.spiderX}): _serverNames = serverNames,_shortIds = shortIds;
  factory _Reality4Ray.fromJson(Map<String, dynamic> json) => _$Reality4RayFromJson(json);

@override final  bool? show;
@override final  String? target;
@override final  String? xver;
 final  List<String>? _serverNames;
@override List<String>? get serverNames {
  final value = _serverNames;
  if (value == null) return null;
  if (_serverNames is EqualUnmodifiableListView) return _serverNames;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

@override final  String? privateKey;
@override final  String? minClientVer;
@override final  String? maxClientVer;
@override final  int? maxTimeDiff;
 final  List<String>? _shortIds;
@override List<String>? get shortIds {
  final value = _shortIds;
  if (value == null) return null;
  if (_shortIds is EqualUnmodifiableListView) return _shortIds;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

@override final  String? mldsa65Seed;
@override final  LimitFallback4Ray? limitFallbackUpload;
@override final  LimitFallback4Ray? limitFallbackDownload;
@override final  String? fingerprint;
@override final  String? serverName;
@override final  String? password;
@override final  String? publicKey;
@override final  String? shortId;
@override final  String? mldsa65Verify;
@override final  String? spiderX;

/// Create a copy of Reality4Ray
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$Reality4RayCopyWith<_Reality4Ray> get copyWith => __$Reality4RayCopyWithImpl<_Reality4Ray>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$Reality4RayToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _Reality4Ray&&(identical(other.show, show) || other.show == show)&&(identical(other.target, target) || other.target == target)&&(identical(other.xver, xver) || other.xver == xver)&&const DeepCollectionEquality().equals(other._serverNames, _serverNames)&&(identical(other.privateKey, privateKey) || other.privateKey == privateKey)&&(identical(other.minClientVer, minClientVer) || other.minClientVer == minClientVer)&&(identical(other.maxClientVer, maxClientVer) || other.maxClientVer == maxClientVer)&&(identical(other.maxTimeDiff, maxTimeDiff) || other.maxTimeDiff == maxTimeDiff)&&const DeepCollectionEquality().equals(other._shortIds, _shortIds)&&(identical(other.mldsa65Seed, mldsa65Seed) || other.mldsa65Seed == mldsa65Seed)&&(identical(other.limitFallbackUpload, limitFallbackUpload) || other.limitFallbackUpload == limitFallbackUpload)&&(identical(other.limitFallbackDownload, limitFallbackDownload) || other.limitFallbackDownload == limitFallbackDownload)&&(identical(other.fingerprint, fingerprint) || other.fingerprint == fingerprint)&&(identical(other.serverName, serverName) || other.serverName == serverName)&&(identical(other.password, password) || other.password == password)&&(identical(other.publicKey, publicKey) || other.publicKey == publicKey)&&(identical(other.shortId, shortId) || other.shortId == shortId)&&(identical(other.mldsa65Verify, mldsa65Verify) || other.mldsa65Verify == mldsa65Verify)&&(identical(other.spiderX, spiderX) || other.spiderX == spiderX));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hashAll([runtimeType,show,target,xver,const DeepCollectionEquality().hash(_serverNames),privateKey,minClientVer,maxClientVer,maxTimeDiff,const DeepCollectionEquality().hash(_shortIds),mldsa65Seed,limitFallbackUpload,limitFallbackDownload,fingerprint,serverName,password,publicKey,shortId,mldsa65Verify,spiderX]);

@override
String toString() {
  return 'Reality4Ray(show: $show, target: $target, xver: $xver, serverNames: $serverNames, privateKey: $privateKey, minClientVer: $minClientVer, maxClientVer: $maxClientVer, maxTimeDiff: $maxTimeDiff, shortIds: $shortIds, mldsa65Seed: $mldsa65Seed, limitFallbackUpload: $limitFallbackUpload, limitFallbackDownload: $limitFallbackDownload, fingerprint: $fingerprint, serverName: $serverName, password: $password, publicKey: $publicKey, shortId: $shortId, mldsa65Verify: $mldsa65Verify, spiderX: $spiderX)';
}


}

/// @nodoc
abstract mixin class _$Reality4RayCopyWith<$Res> implements $Reality4RayCopyWith<$Res> {
  factory _$Reality4RayCopyWith(_Reality4Ray value, $Res Function(_Reality4Ray) _then) = __$Reality4RayCopyWithImpl;
@override @useResult
$Res call({
 bool? show, String? target, String? xver, List<String>? serverNames, String? privateKey, String? minClientVer, String? maxClientVer, int? maxTimeDiff, List<String>? shortIds, String? mldsa65Seed, LimitFallback4Ray? limitFallbackUpload, LimitFallback4Ray? limitFallbackDownload, String? fingerprint, String? serverName, String? password, String? publicKey, String? shortId, String? mldsa65Verify, String? spiderX
});


@override $LimitFallback4RayCopyWith<$Res>? get limitFallbackUpload;@override $LimitFallback4RayCopyWith<$Res>? get limitFallbackDownload;

}
/// @nodoc
class __$Reality4RayCopyWithImpl<$Res>
    implements _$Reality4RayCopyWith<$Res> {
  __$Reality4RayCopyWithImpl(this._self, this._then);

  final _Reality4Ray _self;
  final $Res Function(_Reality4Ray) _then;

/// Create a copy of Reality4Ray
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? show = freezed,Object? target = freezed,Object? xver = freezed,Object? serverNames = freezed,Object? privateKey = freezed,Object? minClientVer = freezed,Object? maxClientVer = freezed,Object? maxTimeDiff = freezed,Object? shortIds = freezed,Object? mldsa65Seed = freezed,Object? limitFallbackUpload = freezed,Object? limitFallbackDownload = freezed,Object? fingerprint = freezed,Object? serverName = freezed,Object? password = freezed,Object? publicKey = freezed,Object? shortId = freezed,Object? mldsa65Verify = freezed,Object? spiderX = freezed,}) {
  return _then(_Reality4Ray(
show: freezed == show ? _self.show : show // ignore: cast_nullable_to_non_nullable
as bool?,target: freezed == target ? _self.target : target // ignore: cast_nullable_to_non_nullable
as String?,xver: freezed == xver ? _self.xver : xver // ignore: cast_nullable_to_non_nullable
as String?,serverNames: freezed == serverNames ? _self._serverNames : serverNames // ignore: cast_nullable_to_non_nullable
as List<String>?,privateKey: freezed == privateKey ? _self.privateKey : privateKey // ignore: cast_nullable_to_non_nullable
as String?,minClientVer: freezed == minClientVer ? _self.minClientVer : minClientVer // ignore: cast_nullable_to_non_nullable
as String?,maxClientVer: freezed == maxClientVer ? _self.maxClientVer : maxClientVer // ignore: cast_nullable_to_non_nullable
as String?,maxTimeDiff: freezed == maxTimeDiff ? _self.maxTimeDiff : maxTimeDiff // ignore: cast_nullable_to_non_nullable
as int?,shortIds: freezed == shortIds ? _self._shortIds : shortIds // ignore: cast_nullable_to_non_nullable
as List<String>?,mldsa65Seed: freezed == mldsa65Seed ? _self.mldsa65Seed : mldsa65Seed // ignore: cast_nullable_to_non_nullable
as String?,limitFallbackUpload: freezed == limitFallbackUpload ? _self.limitFallbackUpload : limitFallbackUpload // ignore: cast_nullable_to_non_nullable
as LimitFallback4Ray?,limitFallbackDownload: freezed == limitFallbackDownload ? _self.limitFallbackDownload : limitFallbackDownload // ignore: cast_nullable_to_non_nullable
as LimitFallback4Ray?,fingerprint: freezed == fingerprint ? _self.fingerprint : fingerprint // ignore: cast_nullable_to_non_nullable
as String?,serverName: freezed == serverName ? _self.serverName : serverName // ignore: cast_nullable_to_non_nullable
as String?,password: freezed == password ? _self.password : password // ignore: cast_nullable_to_non_nullable
as String?,publicKey: freezed == publicKey ? _self.publicKey : publicKey // ignore: cast_nullable_to_non_nullable
as String?,shortId: freezed == shortId ? _self.shortId : shortId // ignore: cast_nullable_to_non_nullable
as String?,mldsa65Verify: freezed == mldsa65Verify ? _self.mldsa65Verify : mldsa65Verify // ignore: cast_nullable_to_non_nullable
as String?,spiderX: freezed == spiderX ? _self.spiderX : spiderX // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

/// Create a copy of Reality4Ray
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$LimitFallback4RayCopyWith<$Res>? get limitFallbackUpload {
    if (_self.limitFallbackUpload == null) {
    return null;
  }

  return $LimitFallback4RayCopyWith<$Res>(_self.limitFallbackUpload!, (value) {
    return _then(_self.copyWith(limitFallbackUpload: value));
  });
}/// Create a copy of Reality4Ray
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$LimitFallback4RayCopyWith<$Res>? get limitFallbackDownload {
    if (_self.limitFallbackDownload == null) {
    return null;
  }

  return $LimitFallback4RayCopyWith<$Res>(_self.limitFallbackDownload!, (value) {
    return _then(_self.copyWith(limitFallbackDownload: value));
  });
}
}


/// @nodoc
mixin _$LimitFallback4Ray {

 int? get afterBytes; int? get bytesPerSec; int? get burstBytesPerSec;
/// Create a copy of LimitFallback4Ray
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LimitFallback4RayCopyWith<LimitFallback4Ray> get copyWith => _$LimitFallback4RayCopyWithImpl<LimitFallback4Ray>(this as LimitFallback4Ray, _$identity);

  /// Serializes this LimitFallback4Ray to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LimitFallback4Ray&&(identical(other.afterBytes, afterBytes) || other.afterBytes == afterBytes)&&(identical(other.bytesPerSec, bytesPerSec) || other.bytesPerSec == bytesPerSec)&&(identical(other.burstBytesPerSec, burstBytesPerSec) || other.burstBytesPerSec == burstBytesPerSec));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,afterBytes,bytesPerSec,burstBytesPerSec);

@override
String toString() {
  return 'LimitFallback4Ray(afterBytes: $afterBytes, bytesPerSec: $bytesPerSec, burstBytesPerSec: $burstBytesPerSec)';
}


}

/// @nodoc
abstract mixin class $LimitFallback4RayCopyWith<$Res>  {
  factory $LimitFallback4RayCopyWith(LimitFallback4Ray value, $Res Function(LimitFallback4Ray) _then) = _$LimitFallback4RayCopyWithImpl;
@useResult
$Res call({
 int? afterBytes, int? bytesPerSec, int? burstBytesPerSec
});




}
/// @nodoc
class _$LimitFallback4RayCopyWithImpl<$Res>
    implements $LimitFallback4RayCopyWith<$Res> {
  _$LimitFallback4RayCopyWithImpl(this._self, this._then);

  final LimitFallback4Ray _self;
  final $Res Function(LimitFallback4Ray) _then;

/// Create a copy of LimitFallback4Ray
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? afterBytes = freezed,Object? bytesPerSec = freezed,Object? burstBytesPerSec = freezed,}) {
  return _then(_self.copyWith(
afterBytes: freezed == afterBytes ? _self.afterBytes : afterBytes // ignore: cast_nullable_to_non_nullable
as int?,bytesPerSec: freezed == bytesPerSec ? _self.bytesPerSec : bytesPerSec // ignore: cast_nullable_to_non_nullable
as int?,burstBytesPerSec: freezed == burstBytesPerSec ? _self.burstBytesPerSec : burstBytesPerSec // ignore: cast_nullable_to_non_nullable
as int?,
  ));
}

}


/// Adds pattern-matching-related methods to [LimitFallback4Ray].
extension LimitFallback4RayPatterns on LimitFallback4Ray {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _LimitFallback4Ray value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _LimitFallback4Ray() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _LimitFallback4Ray value)  $default,){
final _that = this;
switch (_that) {
case _LimitFallback4Ray():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _LimitFallback4Ray value)?  $default,){
final _that = this;
switch (_that) {
case _LimitFallback4Ray() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( int? afterBytes,  int? bytesPerSec,  int? burstBytesPerSec)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _LimitFallback4Ray() when $default != null:
return $default(_that.afterBytes,_that.bytesPerSec,_that.burstBytesPerSec);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( int? afterBytes,  int? bytesPerSec,  int? burstBytesPerSec)  $default,) {final _that = this;
switch (_that) {
case _LimitFallback4Ray():
return $default(_that.afterBytes,_that.bytesPerSec,_that.burstBytesPerSec);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( int? afterBytes,  int? bytesPerSec,  int? burstBytesPerSec)?  $default,) {final _that = this;
switch (_that) {
case _LimitFallback4Ray() when $default != null:
return $default(_that.afterBytes,_that.bytesPerSec,_that.burstBytesPerSec);case _:
  return null;

}
}

}

/// @nodoc
@JsonSerializable()

class _LimitFallback4Ray implements LimitFallback4Ray {
  const _LimitFallback4Ray({this.afterBytes, this.bytesPerSec, this.burstBytesPerSec});
  factory _LimitFallback4Ray.fromJson(Map<String, dynamic> json) => _$LimitFallback4RayFromJson(json);

@override final  int? afterBytes;
@override final  int? bytesPerSec;
@override final  int? burstBytesPerSec;

/// Create a copy of LimitFallback4Ray
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$LimitFallback4RayCopyWith<_LimitFallback4Ray> get copyWith => __$LimitFallback4RayCopyWithImpl<_LimitFallback4Ray>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$LimitFallback4RayToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _LimitFallback4Ray&&(identical(other.afterBytes, afterBytes) || other.afterBytes == afterBytes)&&(identical(other.bytesPerSec, bytesPerSec) || other.bytesPerSec == bytesPerSec)&&(identical(other.burstBytesPerSec, burstBytesPerSec) || other.burstBytesPerSec == burstBytesPerSec));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,afterBytes,bytesPerSec,burstBytesPerSec);

@override
String toString() {
  return 'LimitFallback4Ray(afterBytes: $afterBytes, bytesPerSec: $bytesPerSec, burstBytesPerSec: $burstBytesPerSec)';
}


}

/// @nodoc
abstract mixin class _$LimitFallback4RayCopyWith<$Res> implements $LimitFallback4RayCopyWith<$Res> {
  factory _$LimitFallback4RayCopyWith(_LimitFallback4Ray value, $Res Function(_LimitFallback4Ray) _then) = __$LimitFallback4RayCopyWithImpl;
@override @useResult
$Res call({
 int? afterBytes, int? bytesPerSec, int? burstBytesPerSec
});




}
/// @nodoc
class __$LimitFallback4RayCopyWithImpl<$Res>
    implements _$LimitFallback4RayCopyWith<$Res> {
  __$LimitFallback4RayCopyWithImpl(this._self, this._then);

  final _LimitFallback4Ray _self;
  final $Res Function(_LimitFallback4Ray) _then;

/// Create a copy of LimitFallback4Ray
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? afterBytes = freezed,Object? bytesPerSec = freezed,Object? burstBytesPerSec = freezed,}) {
  return _then(_LimitFallback4Ray(
afterBytes: freezed == afterBytes ? _self.afterBytes : afterBytes // ignore: cast_nullable_to_non_nullable
as int?,bytesPerSec: freezed == bytesPerSec ? _self.bytesPerSec : bytesPerSec // ignore: cast_nullable_to_non_nullable
as int?,burstBytesPerSec: freezed == burstBytesPerSec ? _self.burstBytesPerSec : burstBytesPerSec // ignore: cast_nullable_to_non_nullable
as int?,
  ));
}


}

// dart format on
